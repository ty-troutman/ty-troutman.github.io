---
title: "Making a bar chart using RNA-seq data"
editor: visual
---

In this tutorial we will learn to make a bar chart using RNA-seq data from table S2 in [Seidman et. al. Immunity. Volume 52, Issue 6, 16 June 2020, Pages 1057-1074.e7](https://pubmed.ncbi.nlm.nih.gov/32362324/), which can be downloaded [here](https://ars.els-cdn.com/content/image/1-s2.0-S107476132030159X-mmc3.xlsx). Once we have the data, we will need to open Rstudio and load the necessary packages. We can do that with [library()](https://www.datacamp.com/community/tutorials/r-packages-guide).

```{r, echo=TRUE, message=F, warning=F, results="hide"}
lapply(
  X = c("cowplot", "dplyr", "ggplot2", "readr", "tidyr"),
  FUN = library,
  character.only = TRUE
)
```

In the prior tutorial, we spent time learning how to read in data, and process it into a more friendly, or tidy, format. You can revisit that information [here](Introduction-RNASeqAnalysis.qmd).

With the assumption that this information is fresh in our minds, lets read in a subset of this data. We will select the first 8 columns, and rename these columns to an easier to read format. We will also extract the gene name from column 2 and discard all text after the first occurrence of the '\|' symbol using 'separate.' We will then discard rows containing the same gene using 'distinct.' This occurs because the initial expression table was generated using without the -condenseGenes option using [HOMER analyzeRepeats.pl](http://homer.ucsd.edu/homer/ngs/rnaseq/index.html).

```{r}
# Note, when reading in your data, you should change the path to the
# location/name of your data
colnames(
  readxl::read_xlsx(path = "../Data/Source/1-s2.0-S107476132030159X-mmc3.xlsx")
) %>% head(8)

tb1 <-
  readxl::read_xlsx(path = "../Data/Source/1-s2.0-S107476132030159X-mmc3.xlsx") %>%
  dplyr::select(1:8) %>%
  dplyr::rename(
    accession = 1,
    gene = 2,
    healthy_rep1 = 3,
    healthy_rep2 = 4,
    nash_rep1 = 5,
    nash_rep2 = 6,
    recruited_rep1 = 7,
    recruited_rep2 = 8
  ) %>%
  separate(col = 2, into = "gene", 
           sep = "\\|", # uses regular expression rules
           remove = TRUE, extra = "drop") %>%
  distinct(gene, .keep_all = TRUE)
tb1 %>% head() %>% knitr::kable() #knitr::kable can be used for displaying nicer tables
```

Making plots with ggplot2 requires data to be in a particular format. Each column is a variable, each row should is an observation, and each cell is a single value. Having data in this ['tidy'](https://tidyr.tidyverse.org/articles/tidy-data.html) format is a common goal within the tidyverse. For example:

```{r}
tibble(
  geneName = c("geneA", "geneA", "geneB", "geneB"),
  condition = c("untreated", "treated", "untreated", "treated"),
  expression = c(21, 23, 103, 109)
) %>% knitr::kable()
```

For the purpose of a ggplot2 barplot, we can use dplyr::summarize to calculate the associated statistics. In this case, we don't want to transform our data or pre-calculate the mean. But we do need to shift the data into the 'longer' format as above. We can accomplish this using [tidyr::pivot_longer](https://tidyr.tidyverse.org/reference/pivot_longer.html). In this case, first define which columns should be pivoted using **cols**, then define the variable name assigned to the values column with **values_to**. Variable names for each condition and replicate are generated by splitting on the '\_' character integrated with the rename function when reading in the data. This is done with **names_to** and **names_sep**.

```{r}
tb1 %>%
  pivot_longer(
    cols = -(1:2), # by using a `-`, we can exclude the first two columns
    values_to = c("tpm"),
    names_to = c("condition", "replicate"),
    names_sep  = "_"
  ) %>% head() %>% knitr::kable()
```

With the data in this longer format, we can now use a combination of [dplyr::group_by](https://dplyr.tidyverse.org/reference/group_by.html) and [dplyr::summarise](https://dplyr.tidyverse.org/reference/summarise.html) to calculate the plotting variable we desire for each gene:condition.

```{r}
summary1 <-
  tb1 %>%
  pivot_longer(
    cols = -(1:2),
    values_to = c("tpm"),
    names_to = c("condition", "replicate"),
    names_sep  = "_"
  ) %>%
  group_by(gene, condition) %>%
  summarise(n = n(),
            mean = mean(tpm),
            sd = sd(tpm))
summary1 %>% head() %>% knitr::kable()
```

Now the data is in a suitable tidy format. Ggplot has two options for making [bar charts](https://ggplot2.tidyverse.org/reference/geom_bar.html): geom_bar and geom_col. Read more at the link above. Essentially, **use** ***geom_bar()*** **if the desired plot should be proportional to the number of times an observation occurs**, and **use** ***geom_col()*** **if the plot should be proportional to the values in the data**.

```{r, fig.show="hold", out.width="50%"}
summary1 %>%
  filter(gene == "Adgre1") %>%
  ggplot(aes(x = condition)) +
  geom_bar() +
  ggtitle("geom_bar")

summary1 %>%
  filter(gene == "Adgre1") %>%
  ggplot(aes(x = condition, y = mean)) +
  geom_col(position = position_dodge()) +
  ggtitle("geom_col")
```

We can also add an error bar to the geom_col() using [geom_errorbar() or geom_linerange()](https://ggplot2.tidyverse.org/reference/geom_linerange.html). Layering the error interval onto the bar charts requires defining aesthetic mappings with aes().

```{r, fig.show="hold", out.width="50%"}
summary1 %>%
  filter(gene == "Adgre1") %>%
  ggplot(aes(x = condition, y = mean)) +
  geom_col() +
  geom_errorbar(aes(
    x = condition,
    ymin = mean - sd,
    ymax = mean + sd
  ))

summary1 %>%
  filter(gene == "Adgre1") %>%
  ggplot(aes(x = condition, y = mean)) +
  geom_col() +
  geom_linerange(aes(
    x = condition,
    ymin = mean - sd,
    ymax = mean + sd
  ))
```

Often it will be desired to create a panel of bar charts for several genes of interest. This is quite easy to accomplish with ggplot by adding [facet_wrap](https://ggplot2.tidyverse.org/reference/facet_wrap.html) or [facet_grid](https://ggplot2.tidyverse.org/reference/facet_grid.html) to the ggplot object. In this case, we will also need to retain a few more example genes. These can be added to the filter function directly, or a character vector can be created and intersected within the filter step.

```{r}
goi <- c("Adgre1", "Vsig4", "Clec4f", "Actb", "Timd4", "Tnf")
summary1 %>%
  filter(gene %in% goi) %>%
  ggplot(aes(x = condition, y = mean)) +
  geom_col() +
  geom_linerange(aes(
    x = condition,
    ymin = mean - sd,
    ymax = mean + sd
  )) +
  facet_wrap( ~ gene)
```

In this case, the scales are automatically shared and reflect the range of the supplied data. In this case the scales misrepresent the expression data for genes not expressed at a similar magnitude as beta actin. This can be adjusted by adjusting the 'scales' option to 'free_y' or 'free.'

```{r}
goi <- c("Adgre1", "Vsig4", "Clec4f", "Actb", "Timd4", "Tnf")
summary1 %>%
  filter(gene %in% goi) %>%
  ggplot(aes(x = condition, y = mean)) +
  geom_col() +
  geom_linerange(aes(
    x = condition,
    ymin = mean - sd,
    ymax = mean + sd
  )) +
  facet_wrap( ~ gene, scales = 'free')
```

We can also create bar charts for several genes within one panel by assigning a color or fill parameter in the mapping aesthetics. The data is grouped first by the x/y mapping and then by the fill/color mapping.

```{r, fig.show="hold", out.width="50%"}
goi <- c("Adgre1", "Vsig4", "Clec4f")
summary1 %>%
  filter(gene %in% goi) %>%
  ggplot(aes(x = gene, y = mean, fill = condition)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity") +
  geom_errorbar(
    aes(
      x = gene,
      ymin = mean - sd,
      ymax = mean + sd,
    ),
    width = 0.2,
    position = position_dodge(width = 0.9),
    stat = "identity"
  )

summary1 %>%
  filter(gene %in% goi) %>%
  ggplot(aes(x = condition, y = mean, fill = gene)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity") +
  geom_errorbar(
    aes(
      x = condition,
      ymin = mean - sd,
      ymax = mean + sd,
      colour = gene
    ),
    width = 0.2,
    position = position_dodge(width = 0.9),
    stat = "identity"
  )
```

We can also easily generate sideways barcharts changing mapping to x or y. In this case the error interval mapping must be appropriately altere. As an alterntaive, the chart can be flipped using [coord_flip()](https://ggplot2.tidyverse.org/reference/coord_flip.html).

```{r, fig.show="hold", out.width="50%"}
goi <- c("Adgre1", "Vsig4", "Clec4f")
summary1 %>%
  filter(gene %in% goi) %>%
  ggplot(aes(x = mean, y = gene, fill = condition)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity") +
  geom_errorbar(
    aes(
      y = gene,
      xmin = mean - sd,
      xmax = mean + sd,
    ),
    width = 0.2,
    position = position_dodge(width = 0.9),
    stat = "identity"
  ) +
  ggtitle("Using adjusted ggplot(aes()) and geom_errorbar(aes())")

summary1 %>%
  filter(gene %in% goi) %>%
  ggplot(aes(x = gene, y = mean, fill = condition)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity") +
  geom_errorbar(
    aes(
      x = gene,
      ymin = mean - sd,
      ymax = mean + sd
    ),
    width = 0.2,
    position = position_dodge(width = 0.9),
    stat = "identity"
  ) +
  coord_flip() +
  ggtitle("Using coord_flip()")
```

A publication quality bar chart can be rendered by adjusting parameters to your specifications. Panels can be assembled and easily aligned using the [cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html) and/or the [ggpubr](https://rpkgs.datanovia.com/ggpubr/) packages.

```{r}
library(cowplot)
goi <- c("Adgre1", "Vsig4", "Clec4f", "Actb", "Timd4", "Tnf")
pointSize <- 14
lineWidth <- 1 / 2.835
a <-
  summary1 %>%
  filter(gene %in% goi) %>%
  ggplot(aes(x = condition, y = mean, fill = condition)) +
  geom_col() +
  geom_linerange(aes(
    x = condition,
    ymin = mean - sd,
    ymax = mean + sd
  )) +
  expand_limits(x = 0, y = 0) +
  theme(panel.spacing = unit(1, "lines")) +
  labs(x = NULL, y = c("Transcripts per million +/- SD")) +
  theme(
    text = element_text(size = pointSize, colour = "black"),
    rect = element_blank(),
    line = element_line(size = lineWidth, colour = "black"),
    plot.title  = element_text(size = pointSize * 0.8, colour = "black"),
    axis.title  = element_text(size = pointSize * 0.8, colour = "black"),
    axis.text.x  = element_text(
      size = pointSize * 0.6,
      colour = "black",
      angle = 30,
      hjust = 1
    ),
    axis.text.y  = element_text(size = pointSize * 0.6, colour = "black"),
    legend.position = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_blank(),
    legend.text = element_text(size = pointSize * 0.6, colour = "black"),
    legend.key.height = unit(0.1, "cm"),
    legend.key.width = unit(0.2, "cm"),
    axis.line = element_line(size = lineWidth, colour = "black"),
    plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
    strip.text = element_text(
      face = "italic",
      size = pointSize * 0.6,
      hjust = 0
    ),
    strip.placement = "outside"
  ) +
  scale_fill_viridis_d(option = "viridis") +
  facet_wrap(~ gene, scales = 'free_y')

b <-
  summary1 %>%
  filter(gene %in% c("Adgre1", "Vsig4", "Clec4f")) %>%
  ggplot(aes(x = gene, y = mean, fill = condition)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity") +
  geom_errorbar(
    aes(
      x = gene,
      ymin = mean - sd,
      ymax = mean + sd
    ),
    width = 0.2,
    position = position_dodge(width = 0.9),
    stat = "identity"
  ) +
  expand_limits(x = 0, y = 0) +
  theme(panel.spacing = unit(1, "lines")) +
  labs(x = NULL, y = c("Transcripts per million +/- SD"),) +
  theme(
    text = element_text(size = pointSize, colour = "black"),
    rect = element_blank(),
    line = element_line(size = lineWidth, colour = "black"),
    plot.title  = element_text(size = pointSize * 0.8, colour = "black"),
    axis.title  = element_text(size = pointSize * 0.8, colour = "black"),
    axis.text.x  = element_text(size = pointSize * 0.6, colour = "black"),
    axis.text.y  = element_text(
      size = pointSize * 0.6,
      colour = "black",
      hjust = 1,
      face = "italic"
    ),
    legend.position = "top",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_blank(),
    legend.text = element_text(size = pointSize * 0.6, colour = "black"),
    legend.key.height = unit(0.1, "cm"),
    legend.key.width = unit(0.2, "cm"),
    axis.line = element_line(size = lineWidth, colour = "black"),
    plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
  ) +
  scale_fill_viridis_d(option = "mako") +
  coord_flip()

plot_grid(a,
          b,
          align = "v",
          axis = "bt",
          labels = c("A", "B"))
```

## Finished!

```{R}
sessioninfo::session_info(pkgs = NULL) %>% details::details(summary = 'Current session info', open = TRUE)
```

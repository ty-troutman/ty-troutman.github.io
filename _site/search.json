[
  {
    "objectID": "home.html",
    "href": "home.html",
    "title": "Troutman Lab Internal Website",
    "section": "",
    "text": "Cincinnati Children’s Hospital Medical Center\nDivision of Allergy and Immunology\n240 Albert Sabin Way\nBuilding S, S6.540\nCincinnati, OH 45229"
  },
  {
    "objectID": "Docs/Sequencing/Pooling_Submission.html",
    "href": "Docs/Sequencing/Pooling_Submission.html",
    "title": "Pooling and Submission of Sequencing Libraries",
    "section": "",
    "text": "Critical!! Know which index orientation to submit.\n\n\n\n\n\nVerify the appropriate orientation of the index sequence matches the requirements of the targeted sequencing platform. This must be appropriately entered in the submission sample sheet or demultiplexing will fail. Illumina NovaSeq v1.0 and v1.5 workflows utilize different strategies and require entering i5 index sequences appropriately. Forward strand i5 workflow is performed with v1.0 reagent kits, while reverse complement i5 workflow is performed with v1.5 reagent kits (NovaSeq). For the Illumina MiniSeq or NextSeq platforms, enter the i5 index as the reverse complement. When in doubt, verify with the core facility or sequencing provider and/or read the user manual!!\n\n\n\n\nSubmitting sequencing libraries to the CCHMC DNA Sequencing and Genotyping Core\nThe core manager is David Fletcher.\n\nNon-core generated libraries can only be sequenced on a complete purchased flow cells.\nOne SP flow cell configured at PE150 is $3679, per DNA Core Price Calculator.\nOne lane for external users at UCSD IGM Genomics Center is $3,302 and yields 500 million per lane. - A single SP1 flow cell can yield 1 billion reads, not the core stated 650-750M clusters.\nMore information on submission can be found at the bottom of this page.\nSP flow cells can turn around in 1-3 days, but the cost is ~30% higher than for S4 PE150 data from Novogene.\nData is downloaded individually. The Kottyan and Weirach lab handle this by scraping the download website links, trimming out the samples already downloaded, then running the script on HPC.\n\n\n\nSequencing options:\n    Instrument     Type           Lanes   Cycles          Clusters/Lane(M)   Total Clusters(M) \n    -------------  -------------  ------  --------------  -----------------  ------------------\n    iSeq 100       i1             1       300             4                  4                 \n    MiSeq          MiSeq          1       300, 500, 600   15                 15                \n    NextSeq 500    Mid Output     1       150             130                130               \n    NextSeq 500    High Output    1       75, 150         360                360               \n    NovaSeq 6000   SP (S prime)   1       100, 300, 500   720                720               \n    NovaSeq 6000   S1*            2       100, 200        720                1440              \n    NovaSeq 6000   S2             2       100, 200, 300   1600               3200              \n    NovaSeq 6000   S4             4       200, 300        2000               8000   \n\n\n\n\n\n\n\nNote\n\n\n\nS1 flow cells can be split into separate, independent lanes with the XP workflow. Talk to the core manager ahead of time if this is needed.\n\n\n\n\n\n\n\n\nCritical!!\n\n\n\n\n\nVerify the appropriate orientation of the index sequence matches the requirements of the targeted sequencing platform. This must be appropriately entered in the submission sample sheet or demultiplexing will fail. Illumina NovaSeq v1.0 and v1.5 workflows utilize different strategies and require entering i5 index sequences appropriately. Forward strand i5 workflow is performed with v1.0 reagent kits, while reverse complement i5 workflow is performed with v1.5 reagent kits (NovaSeq). For the Illumina MiniSeq or NextSeq platforms, enter the i5 index as the reverse complement. When in doubt, verify with the core facility or sequencing provider and/or read the user manual!!\n\n\n\n\n\nLane submission requirements:\nSequencing           Min µl   Max µl   Diluent          [Min] \n-------------------  -------  -------  ---------------  ------\nMiSeq                20       50       10 mM Tris-HCl   5 nM  \nNextSeq 500          20       50       10 mM Tris-HCl   5 nM  \nNovaSeq SP, S1, S2   30       50       10 mM Tris-HCl   5 nM  \nNovaSeq S4           65       120      10 mM Tris-HCl   5 nM\n\n\nCCMHC Submission Sample Sheet:\nUse the lab standardized naming convention (linked here)!\n\n\nSubmitting sequencing libraries to Novogene\n\nEmail Justin.Golday@novogeneusa.com to arrange a quote.\nAll runs are PE150 on S4 lanes. To be determined, but for this reason the lab will probably target PE150 for libraries sequenced elsewhere.\nHuman samples exome sequencing and whole genome sequencing require approval and may be subject to change. Be sure to check regulations first.\nThere may be a minimum requirement of >300 million reads per pool.\nSubmit quoted order at 30 µl and 0.5 ng/µl, 2-30 nM.\nTurn around is ~2 weeks.\nAccessing the data is quirky as CCHMC block access by default. The Kottyan and Weirach labs’ work around is to download the data first to their Ohio Super Computer account then transfer to over to HPC. These accounts are linked in some way."
  },
  {
    "objectID": "Docs/Sequencing/Bar-Charts.html",
    "href": "Docs/Sequencing/Bar-Charts.html",
    "title": "Making a bar chart using RNA-seq data",
    "section": "",
    "text": "In this tutorial we will learn to make a bar chart using RNA-seq data from table S2 in Seidman et. al. Immunity. Volume 52, Issue 6, 16 June 2020, Pages 1057-1074.e7, which can be downloaded here. Once we have the data, we will need to open Rstudio and load the necessary packages. We can do that with library().\nIn the prior tutorial, we spent time learning how to read in data, and process it into a more friendly, or tidy, format. You can revisit that information here.\nWith the assumption that this information is fresh in our minds, lets read in a subset of this data. We will select the first 8 columns, and rename these columns to an easier to read format. We will also extract the gene name from column 2 and discard all text after the first occurrence of the ‘|’ symbol using ‘separate.’ We will then discard rows containing the same gene using ‘distinct.’ This occurs because the initial expression table was generated using without the -condenseGenes option using HOMER analyzeRepeats.pl.\nMaking plots with ggplot2 requires data to be in a particular format. Each column is a variable, each row should is an observation, and each cell is a single value. Having data in this ‘tidy’ format is a common goal within the tidyverse. For example:\nFor the purpose of a ggplot2 barplot, we can use dplyr::summarize to calculate the associated statistics. In this case, we don’t want to transform our data or pre-calculate the mean. But we do need to shift the data into the ‘longer’ format as above. We can accomplish this using tidyr::pivot_longer. In this case, first define which columns should be pivoted using cols, then define the variable name assigned to the values column with values_to. Variable names for each condition and replicate are generated by splitting on the ‘_’ character integrated with the rename function when reading in the data. This is done with names_to and names_sep.\nWith the data in this longer format, we can now use a combination of dplyr::group_by and dplyr::summarise to calculate the plotting variable we desire for each gene:condition.\nNow the data is in a suitable tidy format. Ggplot has two options for making bar charts: geom_bar and geom_col. Read more at the link above. Essentially, use geom_bar() if the desired plot should be proportional to the number of times an observation occurs, and use geom_col() if the plot should be proportional to the values in the data.\nWe can also add an error bar to the geom_col() using geom_errorbar() or geom_linerange(). Layering the error interval onto the bar charts requires defining aesthetic mappings with aes().\nOften it will be desired to create a panel of bar charts for several genes of interest. This is quite easy to accomplish with ggplot by adding facet_wrap or facet_grid to the ggplot object. In this case, we will also need to retain a few more example genes. These can be added to the filter function directly, or a character vector can be created and intersected within the filter step.\nIn this case, the scales are automatically shared and reflect the range of the supplied data. In this case the scales misrepresent the expression data for genes not expressed at a similar magnitude as beta actin. This can be adjusted by adjusting the ‘scales’ option to ‘free_y’ or ‘free.’\nWe can also create bar charts for several genes within one panel by assigning a color or fill parameter in the mapping aesthetics. The data is grouped first by the x/y mapping and then by the fill/color mapping.\nWe can also easily generate sideways barcharts changing mapping to x or y. In this case the error interval mapping must be appropriately altere. As an alterntaive, the chart can be flipped using coord_flip().\nA publication quality bar chart can be rendered by adjusting parameters to your specifications. Panels can be assembled and easily aligned using the cowplot and/or the ggpubr packages."
  },
  {
    "objectID": "Docs/Sequencing/Bar-Charts.html#finished",
    "href": "Docs/Sequencing/Bar-Charts.html#finished",
    "title": "Making a bar chart using RNA-seq data",
    "section": "Finished!",
    "text": "Finished!\n\nsessioninfo::session_info(pkgs = NULL) %>% details::details(summary = 'Current session info', open = TRUE)\n\n\n\n Current session info \n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.0 (2021-05-18)\n os       macOS Big Sur 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-05-04\n pandoc   2.17.1.1 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n assertthat    0.2.1   2019-03-21 [2] CRAN (R 4.1.0)\n cellranger    1.1.0   2016-07-27 [2] CRAN (R 4.1.0)\n cli           3.1.1   2022-01-20 [1] CRAN (R 4.1.2)\n clipr         0.7.1   2020-10-08 [2] CRAN (R 4.1.0)\n colorspace    2.0-2   2021-06-24 [2] CRAN (R 4.1.0)\n cowplot     * 1.1.1   2020-12-30 [2] CRAN (R 4.1.0)\n crayon        1.4.2   2021-10-29 [2] CRAN (R 4.1.0)\n DBI           1.1.2   2021-12-20 [2] CRAN (R 4.1.0)\n desc          1.4.0   2021-09-28 [1] CRAN (R 4.1.0)\n details       0.2.1   2020-01-12 [2] CRAN (R 4.1.0)\n digest        0.6.29  2021-12-01 [2] CRAN (R 4.1.0)\n dplyr       * 1.0.8   2022-02-08 [2] CRAN (R 4.1.0)\n ellipsis      0.3.2   2021-04-29 [2] CRAN (R 4.1.0)\n evaluate      0.14    2019-05-28 [2] CRAN (R 4.1.0)\n fansi         1.0.2   2022-01-14 [2] CRAN (R 4.1.2)\n farver        2.1.0   2021-02-28 [2] CRAN (R 4.1.0)\n fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.1.0)\n generics      0.1.2   2022-01-31 [2] CRAN (R 4.1.2)\n ggplot2     * 3.3.5   2021-06-25 [2] CRAN (R 4.1.0)\n glue          1.6.1   2022-01-22 [2] CRAN (R 4.1.2)\n gtable        0.3.0   2019-03-25 [2] CRAN (R 4.1.0)\n highr         0.9     2021-04-16 [2] CRAN (R 4.1.0)\n hms           1.1.1   2021-09-26 [2] CRAN (R 4.1.0)\n htmltools     0.5.2   2021-08-25 [2] CRAN (R 4.1.0)\n htmlwidgets   1.5.4   2021-09-08 [1] CRAN (R 4.1.0)\n httr          1.4.2   2020-07-20 [2] CRAN (R 4.1.0)\n jsonlite      1.7.3   2022-01-17 [2] CRAN (R 4.1.2)\n knitr         1.37    2021-12-16 [2] CRAN (R 4.1.0)\n labeling      0.4.2   2020-10-20 [2] CRAN (R 4.1.0)\n lifecycle     1.0.1   2021-09-24 [2] CRAN (R 4.1.0)\n magrittr      2.0.2   2022-01-26 [2] CRAN (R 4.1.2)\n munsell       0.5.0   2018-06-12 [2] CRAN (R 4.1.0)\n pillar        1.7.0   2022-02-01 [2] CRAN (R 4.1.2)\n pkgconfig     2.0.3   2019-09-22 [2] CRAN (R 4.1.0)\n png           0.1-7   2013-12-03 [2] CRAN (R 4.1.0)\n purrr         0.3.4   2020-04-17 [2] CRAN (R 4.1.0)\n R6            2.5.1   2021-08-19 [2] CRAN (R 4.1.0)\n Rcpp          1.0.8   2022-01-13 [2] CRAN (R 4.1.2)\n readr       * 2.1.2   2022-01-30 [1] CRAN (R 4.1.2)\n readxl        1.3.1   2019-03-13 [2] CRAN (R 4.1.0)\n rlang         1.0.1   2022-02-03 [2] CRAN (R 4.1.2)\n rmarkdown     2.11    2021-09-14 [1] CRAN (R 4.1.0)\n rprojroot     2.0.2   2020-11-15 [1] CRAN (R 4.1.0)\n rstudioapi    0.13    2020-11-12 [2] CRAN (R 4.1.0)\n scales        1.1.1   2020-05-11 [2] CRAN (R 4.1.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.1.0)\n stringi       1.7.6   2021-11-29 [2] CRAN (R 4.1.0)\n stringr       1.4.0   2019-02-10 [2] CRAN (R 4.1.0)\n tibble        3.1.6   2021-11-07 [2] CRAN (R 4.1.0)\n tidyr       * 1.2.0   2022-02-01 [2] CRAN (R 4.1.2)\n tidyselect    1.1.1   2021-04-30 [2] CRAN (R 4.1.0)\n tzdb          0.2.0   2021-10-27 [2] CRAN (R 4.1.0)\n utf8          1.2.2   2021-07-24 [2] CRAN (R 4.1.0)\n vctrs         0.3.8   2021-04-29 [2] CRAN (R 4.1.0)\n viridisLite   0.4.0   2021-04-13 [2] CRAN (R 4.1.0)\n withr         2.4.3   2021-11-30 [1] CRAN (R 4.1.0)\n xfun          0.29    2021-12-14 [1] CRAN (R 4.1.0)\n xml2          1.3.3   2021-11-30 [2] CRAN (R 4.1.0)\n yaml          2.2.2   2022-01-25 [2] CRAN (R 4.1.2)\n\n [1] /Users/tro3nr/Library/R/x86_64/4.1/library\n [2] /Library/Frameworks/R.framework/Versions/4.1/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "Docs/Sequencing/Database_Barcodes.html",
    "href": "Docs/Sequencing/Database_Barcodes.html",
    "title": "Sequencing Database and Barcodes",
    "section": "",
    "text": "Required!\n\n\n\n\n\nUse the linked database to generate a sample name with a unique id and to track associated meta data"
  },
  {
    "objectID": "Docs/Sequencing/Database_Barcodes.html#instructions",
    "href": "Docs/Sequencing/Database_Barcodes.html#instructions",
    "title": "Sequencing Database and Barcodes",
    "section": "Instructions",
    "text": "Instructions\nTo be updated\n\nArrange access through the lab manager or Ty.\nDo not delete other peoples entries!\nHighlighted columns are required and used for generating sample names.\nUse generated sample names in submitted sample sheets.\nTrack relevant meta data in additional columns."
  },
  {
    "objectID": "Docs/Sequencing/Database_Barcodes.html#standard-sequencing-barcodes-available-in-the-lab",
    "href": "Docs/Sequencing/Database_Barcodes.html#standard-sequencing-barcodes-available-in-the-lab",
    "title": "Sequencing Database and Barcodes",
    "section": "Standard Sequencing Barcodes Available in the Lab",
    "text": "Standard Sequencing Barcodes Available in the Lab\n\n\n\n\n\n\nImportant\n\n\n\n\n\nNot all barcodes sequences between manufacturers are compatible with each other. It is important to plan ahead, consider Hamming distances, GC balance, and communicate with colleagues to facilitate multiplexing. Examples for determining Hamming distances can be found in the GitHub repository below.\n\n\n\nSequencing Barcode Information\nBarcode Analyses, Lists, Sources and More\n\nNEXTFLEX UDI Barcodes\n\n\n\n\n\n\nImportant\n\n\n\n\n\nNever thaw the annealed adapters above room temperatur or they can denature. Mix carefully and centrifuge prior to opening. Handle carefully to avoid downstream adapter cross-contamination.\n\n\n\nWe have three sets of NEXTFLEX full-length unique dual index (UDI) barcoding adapters from Perkin Elmer. These adapters are for use in ligation chemistry (lab standard dUTP RNA-seq and ChIP-seq protocols). They contain a unique 8 nucleotide index in the P5 (i5) and P7 (i7) sequence. Each pair was designed with a Hamming distance of at least 3 across the entire series of 384 UDI barcodes, meaning any two or more chosen NEXTFLEX UDI adapters in the entire set are internally compatible with themselves. They are not all appropriately GC balanced though. These UDI barcodes are purchased in sets of 96 adapters. We purchased set 4 (barcodes 289:384) and were gifted small aliquots of set 1 (1:96) and set 2 (97:192) from the labs’ of Chris Glass and Sven Heinz at UC San Diego.\nAdapter stocks are delivered at 25 µM and diluted to 0.625 µM in 1X T4 DNA ligase buffer (10X T4 ligase buffer, NEB #B0202S; dilute 1:10 with ultra-pure water to obtain 1X buffer). Diluted stocks are further diluted to 0.25 µM as routine use aliquots. Typically, 0.5 to 1 µl of the working aliquot is adequate for adapter ligation. Barcoded libraries are amplified using NEXTFLEX common primer sequences.\nNEXTFLEX PCR Primer 1: AATGATACGGCGACCACCGAGATCTACAC \nNEXTFLEX PCR Primer 2: CAAGCAGAAGACGGCATACGAGAT\n\nNEXTFLEX P5 Adapter: AATGATACGGCGACCACCGAGATCTACACXXXXXXXXACACTCTTTCCCTACACGACGCTCTTCCGATCT NEXTFLEX P7 Adapter: GATCGGAAGAGCACACGTCTGAACTCCAGTCACXXXXXXXXATCTCGTATGCCGTCTTCTGCTTG\n\n\n\n\n\n\nNote\n\n\n\nXXXXXXXX denotes the P5 or P7 index region of the adapter.\n\n\n\n\nTn5 Barcoding Primers\nBuenrostro et. al. Nature, 2015. PMID: 26083756.\nTn5 transposase barcoding primers for (ATAC-seq and other suitable transposase chemistry libraries) were sourced from the labs’ of Howard Chang and William Greenleaf (Supplementary Table 1 of the linked manuscript). Each primer contains a unique 8 nucleotide index. Combinatorial or unique P5 and P7 primers are selected for each sample and are used as primers for PCR amplfication of ATAC-seq libraries.\nPrimers were ordered from IDT as standard oligonucleotides and resuspended at 10 µM in low-EDTA TE buffer. Reconstituted primers stocks are stored at -20C. Working aliquots should be used routinely in place of the stocks.\nTn5 P5 Primer Sequence: AATGATACGGCGACCACCGAGATCTACACXXXXXXXXTCGTCGGCAGCGTCAGATGTGTAT\nTn5 P7 Primer Sequence: CAAGCAGAAGACGGCATACGAGATXXXXXXXXGTCTCGTGGGCTCGGAGATGTG\n\n\n\n\n\n\nNote\n\n\n\nXXXXXXXX denotes the P5 or P7 index region of the primer."
  },
  {
    "objectID": "Docs/Sequencing/Database_Barcodes.html#additional-information",
    "href": "Docs/Sequencing/Database_Barcodes.html#additional-information",
    "title": "Sequencing Database and Barcodes",
    "section": "Additional information",
    "text": "Additional information\nFor barcoded adapters added via ligation (e.g. NEXTFLEX UDI, standard Truseq style Y-adapters):\n\nindex 1 (i7) is always read in the direction (5’ to 3′) of the sequence in the oligo\nindex 2 (i5) is read in the direction of the oligos for Miseq and NovaSeq runs\nindex 2 (i5) is read as reverse complement of barcoded PCR oligos for NextSeq and iSeq runs\n\nFor barcodes added via a PCR step (e.g. Tn5 Transposase Barcoding PCR Primers, Nextera; or through primers and stubby adapters):\n\nindex 1 (i7) is always read as reverse complement of the sequence in TruSeq or Nextera style PCR oligos\nindex 2 (i5) is read in direction of TruSeq or Nextera PCR oligos for Miseq and NovaSeq runs\nindex 2 (i5) is read as reverse complement of barcoded PCR oligos for NextSeq and iSeq runs"
  },
  {
    "objectID": "Docs/Sequencing/Introduction-RNASeqAnalysis.html",
    "href": "Docs/Sequencing/Introduction-RNASeqAnalysis.html",
    "title": "An introductory exploration of RNA-seq data using R and tidyverse",
    "section": "",
    "text": "Commenting your code can help you and others understand what you were doing. A comment is generated using ‘#’.\nYou can navigate your computer as follows:\n\n# how to find your working directory\ngetwd()\n\n[1] \"/Users/tro3nr/OneDrive - cchmc/Websites/Troutman Lab Internal Website/Docs/Sequencing\"\n\n# how to list directory files\nlist.files()\n\n[1] \"Bar-Charts_files\"                                \n[2] \"Bar-Charts.html\"                                 \n[3] \"Bar-Charts.qmd\"                                  \n[4] \"Exporting-Gene-Lists.qmd\"                        \n[5] \"Integrating-RNASeq-ExpressionTPM-with-DeSeq2.qmd\"\n[6] \"Introduction-RNASeqAnalysis.qmd\"                 \n[7] \"Introduction-RNASeqAnalysis.rmarkdown\"           \n[8] \"Nested-Bar-Charts.qmd\"                           \n[9] \"ngsScraper_KevinErnst.qmd\"                       \n\n#how to list sub directories\nlist.dirs()\n\n[1] \".\"                              \"./Bar-Charts_files\"            \n[3] \"./Bar-Charts_files/figure-html\"\n\n# how to list files from someplace other than your working directory\nlist.files(\"../Data/Source/\")\n\n [1] \"1-s2.0-S107476132030159X-mmc3.xlsx\"                 \n [2] \"BALBcJ_F0_Control.vs.C57BL6J_F0_Control.scatter.txt\"\n [3] \"BALBcJ_F1_Control.vs.C57BL6J_F1_Control.scatter.txt\"\n [4] \"C57BL6J_F0_Control.vs.BALBcJ_F0_Control.scatter.txt\"\n [5] \"C57BL6J_F1_Control.vs.BALBcJ_F1_Control.scatter.txt\"\n [6] \"deseq2_kc_control_lps_f0_f1.txt\"                    \n [7] \"HOMER.rawCount.txt\"                                 \n [8] \"HOMER.rawTPM.txt\"                                   \n [9] \"rawC.txt\"                                           \n[10] \"rawT.txt\"                                           \n[11] \"rnaSeq_tableS2_seidman_immunity_2020.csv\"           \n\n# how to make a new directory\n# dir.create(\"~/Documents/example\")\n\n# how to change your working directory\n# setwd(\"./\")"
  },
  {
    "objectID": "Docs/Sequencing/Introduction-RNASeqAnalysis.html#reading-in-data",
    "href": "Docs/Sequencing/Introduction-RNASeqAnalysis.html#reading-in-data",
    "title": "An introductory exploration of RNA-seq data using R and tidyverse",
    "section": "Reading in data",
    "text": "Reading in data\nIn this tutorial we will make a scatter plot using RNA-seq data from table S2 in Seidman et. al. Immunity. Volume 52, Issue 6, 16 June 2020, Pages 1057-1074.e7, which can be downloaded here. Once we have the data, we will need to open Rstudio and load the necessary packages. We can do that with library().\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n✓ tibble  3.1.6     ✓ dplyr   1.0.8\n✓ tidyr   1.2.0     ✓ stringr 1.4.0\n✓ readr   2.1.2     ✓ forcats 0.5.1\n\n\nWarning: package 'tidyr' was built under R version 4.1.2\n\n\nWarning: package 'readr' was built under R version 4.1.2\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\n\nNow we can use read_excel() from the readxl package to load our excel spreadsheet. We can use readr:read_csv() or readr:read_tsv() to load .csv and .txt files.\n\n# read in our data\ntb1 <- \n  readxl::read_excel(\n  path = \"../Data/Source/1-s2.0-S107476132030159X-mmc3.xlsx\") \n\n\ntb1\n\n# A tibble: 40,458 × 48\n   `Transcript/RepeatID (cm…` `Annotation/Di…` `KCH_rep1_figu…` `KCH_rep2_figu…`\n   <chr>                      <chr>                       <dbl>            <dbl>\n 1 NM_001329047               Mia2|Ctage5|D12…            43.6             36.3 \n 2 NM_172405                  Abraxas1|383040…             1.91             2.20\n 3 NM_001359283               Sec63|5730478J1…            19.3             17.8 \n 4 NM_001168290               Sugp2|Sfrs14|Sr…            11.5              8.86\n 5 NM_001356498               Mtmr12|3Pap|493…             7.14             8.74\n 6 NM_001358950               Cbx5|2610029O15…             6.53             6.21\n 7 NM_001166375               March1|2900024D…            58.3             67.8 \n 8 NM_178061                  Mob3b|8430436F2…             1.51             1.61\n 9 NR_126506                  Mdm4|4933417N07…            29.2             25.6 \n10 NR_029557                  Mir145a|Mir145|…             0                0   \n# … with 40,448 more rows, and 44 more variables: `KCN_rep1_figure1,3,4` <dbl>,\n#   `KCN_rep2_figure1,3,4` <dbl>, `KN-RM_rep1_figure1,3,4` <dbl>,\n#   `KN-RM_rep2_figure1,3,4` <dbl>, `Ly6CHi-RM_rep1_figure1,3,4` <dbl>,\n#   `Ly6CHi-RM_rep2_figure1,3,4` <dbl>, `Ly6CLow-RM_rep1_figure1,3,4` <dbl>,\n#   `Ly6CLow-RM_rep2_figure1,3,4` <dbl>,\n#   `BloodLy6CHi-Mono_Control_rep1_figure3,4` <dbl>,\n#   `BloodLy6CHi-Mono_Control_rep2_figure3,4` <dbl>, …\n\n\nWe can use colnames() to see the names of the columns in this table.\n\ncolnames(x = tb1)\n\n [1] \"Transcript/RepeatID (cmd=analyzeRepeats.pl rna mm10 -count exons -tpm -dfile Table_S2_dfile.txt)\"\n [2] \"Annotation/Divergence\"                                                                           \n [3] \"KCH_rep1_figure1,3,4\"                                                                            \n [4] \"KCH_rep2_figure1,3,4\"                                                                            \n [5] \"KCN_rep1_figure1,3,4\"                                                                            \n [6] \"KCN_rep2_figure1,3,4\"                                                                            \n [7] \"KN-RM_rep1_figure1,3,4\"                                                                          \n [8] \"KN-RM_rep2_figure1,3,4\"                                                                          \n [9] \"Ly6CHi-RM_rep1_figure1,3,4\"                                                                      \n[10] \"Ly6CHi-RM_rep2_figure1,3,4\"                                                                      \n[11] \"Ly6CLow-RM_rep1_figure1,3,4\"                                                                     \n[12] \"Ly6CLow-RM_rep2_figure1,3,4\"                                                                     \n[13] \"BloodLy6CHi-Mono_Control_rep1_figure3,4\"                                                         \n[14] \"BloodLy6CHi-Mono_Control_rep2_figure3,4\"                                                         \n[15] \"BloodLy6CHi-Mono_NASH_rep1_figure3,4\"                                                            \n[16] \"BloodLy6CHi-Mono_NASH_rep2_figure3,4\"                                                            \n[17] \"BloodLy6CHi-Mono_Control_rep3_figure3,4\"                                                         \n[18] \"BloodLy6CHi-Mono_Control_rep4_figure3,4\"                                                         \n[19] \"RLM_DT1D_rep1_figure3\"                                                                           \n[20] \"RLM_DT1D_rep2_figure3\"                                                                           \n[21] \"RLM_DT1D_rep3_figure3\"                                                                           \n[22] \"RLM_DT14D_rep1_figure3\"                                                                          \n[23] \"RLM_DT14D_rep2_figure3\"                                                                          \n[24] \"RLM_DT14D_rep3_figure3\"                                                                          \n[25] \"RLM_DT12H_rep1_figure3\"                                                                          \n[26] \"RLM_DT12H_rep2_figure3\"                                                                          \n[27] \"wholeLiver_DTRN_rep1_figure3\"                                                                    \n[28] \"wholeLiver_DTRN_rep2_figure3\"                                                                    \n[29] \"wholeLiver_DTRN_rep3_figure3\"                                                                    \n[30] \"wholeLiver_DTRN_rep4_figure3\"                                                                    \n[31] \"wholeLiver_DTRN_rep5_figure3\"                                                                    \n[32] \"wholeLiver_DTRN_rep6_figure3\"                                                                    \n[33] \"wholeLiver_DTRN_rep7_figure3\"                                                                    \n[34] \"wholeLiver_DTRN_rep8_figure3\"                                                                    \n[35] \"wholeLiver_DTRN_rep9_figure3\"                                                                    \n[36] \"wholeLiver_DTRN_rep10_figure3\"                                                                   \n[37] \"wholeLiver_DTRP_rep1_figure3\"                                                                    \n[38] \"wholeLiver_DTRP_rep2_figure3\"                                                                    \n[39] \"wholeLiver_DTRP_rep3_figure3\"                                                                    \n[40] \"wholeLiver_DTRP_rep4_figure3\"                                                                    \n[41] \"wholeLiver_DTRP_rep5_figure3\"                                                                    \n[42] \"wholeLiver_DTRP_rep6_figure3\"                                                                    \n[43] \"wholeLiver_DTRP_rep7_figure3\"                                                                    \n[44] \"wholeLiver_DTRP_rep8_figure3\"                                                                    \n[45] \"wholeLiver_DTRP_rep9_figure3\"                                                                    \n[46] \"wholeLiver_DTRP_rep10_figure3\"                                                                   \n[47] \"wholeLiver_DTRP_rep11_figure3\"                                                                   \n[48] \"wholeLiver_DTRP_rep12_figure3\"                                                                   \n\n\nThat’s a lot of data, lets only keeps a small part that we want to practice with for now. To do this let’s keep the first two columns, which have gene identifier information, and lets keep the next 4 column which are replicate RNA-seq data for two conditions. To keep these columns, we will use the dplyr::select() verb, which operates on columns.\n\ndplyr::select(.data = tb1, 1:6) # this format gives us column 1 to 6, and everything between\n\n# A tibble: 40,458 × 6\n   `Transcript/RepeatID (cm…` `Annotation/Di…` `KCH_rep1_figu…` `KCH_rep2_figu…`\n   <chr>                      <chr>                       <dbl>            <dbl>\n 1 NM_001329047               Mia2|Ctage5|D12…            43.6             36.3 \n 2 NM_172405                  Abraxas1|383040…             1.91             2.20\n 3 NM_001359283               Sec63|5730478J1…            19.3             17.8 \n 4 NM_001168290               Sugp2|Sfrs14|Sr…            11.5              8.86\n 5 NM_001356498               Mtmr12|3Pap|493…             7.14             8.74\n 6 NM_001358950               Cbx5|2610029O15…             6.53             6.21\n 7 NM_001166375               March1|2900024D…            58.3             67.8 \n 8 NM_178061                  Mob3b|8430436F2…             1.51             1.61\n 9 NR_126506                  Mdm4|4933417N07…            29.2             25.6 \n10 NR_029557                  Mir145a|Mir145|…             0                0   \n# … with 40,448 more rows, and 2 more variables: `KCN_rep1_figure1,3,4` <dbl>,\n#   `KCN_rep2_figure1,3,4` <dbl>\n\ndplyr::select(.data = tb1, c(1, 2, 3, 4, 5, 6)) # this format declares which columns to keep in order\n\n# A tibble: 40,458 × 6\n   `Transcript/RepeatID (cm…` `Annotation/Di…` `KCH_rep1_figu…` `KCH_rep2_figu…`\n   <chr>                      <chr>                       <dbl>            <dbl>\n 1 NM_001329047               Mia2|Ctage5|D12…            43.6             36.3 \n 2 NM_172405                  Abraxas1|383040…             1.91             2.20\n 3 NM_001359283               Sec63|5730478J1…            19.3             17.8 \n 4 NM_001168290               Sugp2|Sfrs14|Sr…            11.5              8.86\n 5 NM_001356498               Mtmr12|3Pap|493…             7.14             8.74\n 6 NM_001358950               Cbx5|2610029O15…             6.53             6.21\n 7 NM_001166375               March1|2900024D…            58.3             67.8 \n 8 NM_178061                  Mob3b|8430436F2…             1.51             1.61\n 9 NR_126506                  Mdm4|4933417N07…            29.2             25.6 \n10 NR_029557                  Mir145a|Mir145|…             0                0   \n# … with 40,448 more rows, and 2 more variables: `KCN_rep1_figure1,3,4` <dbl>,\n#   `KCN_rep2_figure1,3,4` <dbl>\n\n\nWe can also pipe commands from left to right using magrittr %>% operator. This allows us to chain operations together so that we don’t need to define a bunch of variables to store in memory, or overwrite variables by reusing variable names. Reusing variable names can lead to bugs in our analyses (if we aren’t careful)!\n\ntb1 <- readxl::read_xlsx(\n  path = \"../Data/Source/1-s2.0-S107476132030159X-mmc3.xlsx\") %>% \n  dplyr::select(1:6) \ntb1\n\n# A tibble: 40,458 × 6\n   `Transcript/RepeatID (cm…` `Annotation/Di…` `KCH_rep1_figu…` `KCH_rep2_figu…`\n   <chr>                      <chr>                       <dbl>            <dbl>\n 1 NM_001329047               Mia2|Ctage5|D12…            43.6             36.3 \n 2 NM_172405                  Abraxas1|383040…             1.91             2.20\n 3 NM_001359283               Sec63|5730478J1…            19.3             17.8 \n 4 NM_001168290               Sugp2|Sfrs14|Sr…            11.5              8.86\n 5 NM_001356498               Mtmr12|3Pap|493…             7.14             8.74\n 6 NM_001358950               Cbx5|2610029O15…             6.53             6.21\n 7 NM_001166375               March1|2900024D…            58.3             67.8 \n 8 NM_178061                  Mob3b|8430436F2…             1.51             1.61\n 9 NR_126506                  Mdm4|4933417N07…            29.2             25.6 \n10 NR_029557                  Mir145a|Mir145|…             0                0   \n# … with 40,448 more rows, and 2 more variables: `KCN_rep1_figure1,3,4` <dbl>,\n#   `KCN_rep2_figure1,3,4` <dbl>\n\n\nThese column names could be made easier. Let’s rename them using the dplyr verb dplyr::rename.\n\ntb1 <- readxl::read_xlsx(\n  path = \"../Data/Source/1-s2.0-S107476132030159X-mmc3.xlsx\") \ntb1 <- dplyr::select(tb1, 1:6)\ntb1 <- rename(.data = tb1, accession = 1, gene = 2, kch_rep1 = 3, kch_rep2 = 4, kn_rep1 = 5, kn_rep2 = 6)\ntb1\n\n# A tibble: 40,458 × 6\n   accession    gene                           kch_rep1 kch_rep2 kn_rep1 kn_rep2\n   <chr>        <chr>                             <dbl>    <dbl>   <dbl>   <dbl>\n 1 NM_001329047 Mia2|Ctage5|D12Bwg0579e|Mea6|…    43.6     36.3   29.6    26.8  \n 2 NM_172405    Abraxas1|3830405G04Rik|563040…     1.91     2.20   1.95    1.82 \n 3 NM_001359283 Sec63|5730478J10Rik|AI649014|…    19.3     17.8   13.2    12.9  \n 4 NM_001168290 Sugp2|Sfrs14|Srsf14|mKIAA0365…    11.5      8.86  10.9     7.57 \n 5 NM_001356498 Mtmr12|3Pap|4932703C11|C73001…     7.14     8.74   6.71    6.84 \n 6 NM_001358950 Cbx5|2610029O15Rik|C75991|HP1…     6.53     6.21   5.86    7.20 \n 7 NM_001166375 March1|2900024D24Rik|BB085186…    58.3     67.8   49.4    50.2  \n 8 NM_178061    Mob3b|8430436F23Rik|A430018A0…     1.51     1.61   0.729   0.906\n 9 NR_126506    Mdm4|4933417N07Rik|AA414968|A…    29.2     25.6   16.4    13.3  \n10 NR_029557    Mir145a|Mir145|Mirn145|mir-14…     0        0      0       0    \n# … with 40,448 more rows\n\n\nThe above snippet is equivalent to using a string of pipes to parse the data prior to generating the final variable:\n\ntb1 <-\n  readxl::read_xlsx(path = \"../Data/Source/1-s2.0-S107476132030159X-mmc3.xlsx\") %>%\n  dplyr::select(1:6) %>%\n  dplyr::rename(\n    accession = 1,\n    gene = 2,\n    kch_rep1 = 3,\n    kch_rep2 = 4,\n    kn_rep1 = 5,\n    kn_rep2 = 6\n  )\ntb1\n\n# A tibble: 40,458 × 6\n   accession    gene                           kch_rep1 kch_rep2 kn_rep1 kn_rep2\n   <chr>        <chr>                             <dbl>    <dbl>   <dbl>   <dbl>\n 1 NM_001329047 Mia2|Ctage5|D12Bwg0579e|Mea6|…    43.6     36.3   29.6    26.8  \n 2 NM_172405    Abraxas1|3830405G04Rik|563040…     1.91     2.20   1.95    1.82 \n 3 NM_001359283 Sec63|5730478J10Rik|AI649014|…    19.3     17.8   13.2    12.9  \n 4 NM_001168290 Sugp2|Sfrs14|Srsf14|mKIAA0365…    11.5      8.86  10.9     7.57 \n 5 NM_001356498 Mtmr12|3Pap|4932703C11|C73001…     7.14     8.74   6.71    6.84 \n 6 NM_001358950 Cbx5|2610029O15Rik|C75991|HP1…     6.53     6.21   5.86    7.20 \n 7 NM_001166375 March1|2900024D24Rik|BB085186…    58.3     67.8   49.4    50.2  \n 8 NM_178061    Mob3b|8430436F23Rik|A430018A0…     1.51     1.61   0.729   0.906\n 9 NR_126506    Mdm4|4933417N07Rik|AA414968|A…    29.2     25.6   16.4    13.3  \n10 NR_029557    Mir145a|Mir145|Mirn145|mir-14…     0        0      0       0    \n# … with 40,448 more rows"
  },
  {
    "objectID": "Docs/Sequencing/Introduction-RNASeqAnalysis.html#a-basic-scatter-plot",
    "href": "Docs/Sequencing/Introduction-RNASeqAnalysis.html#a-basic-scatter-plot",
    "title": "An introductory exploration of RNA-seq data using R and tidyverse",
    "section": "A Basic Scatter Plot",
    "text": "A Basic Scatter Plot\nNow we have some tidy data, let’s compare the replicates by making a scatterplot! We can accomplish this using ggplot2 and the geom_point() layer\nNotice that we pipe our tidy data into ggplot2 as before with ‘%>%’. However, for assembling a ggplot script, we instead ‘add’ each component together in series using the ‘+’. This happens after initiating the ggplot() function call. After this point, we should for now think of the data as no longer requiring manipulation using function outside of ggplot context. See Hadley Wickham’s answer for a better understanding on why ggplot2 uses ‘+’ and not ‘%>%’.\n\ntb1 %>% \n  ggplot() + # + not %>%\n  geom_point(mapping = aes(x = kch_rep1,\n                           y = kch_rep2))\n\n\n\n\nThis works, but we notice here that the RNA-seq data is not normally distributed. Instead it is log normal. This means if we want to best visualize a lot of genes at the same time, we should first transform them. We accomplish this by adding 1 to each data point, then taking the log base 2 of each data point: log2(dataExample + 1). This transform can be easily wrapped into the ggplot code. To learn more about how to use R to comput logarithms and exponents, click this link or type ‘?log()’ into the R console.\n\ntb1 %>%\n  ggplot() +\n  geom_point(mapping = aes(x = log2(kch_rep1 + 1),\n                           y = log2(kch_rep2 + 1)))\n\n\n\n\nDo the same thing but with the other pair of data:\n\ntb1 %>%\n  ggplot() +\n  geom_point(mapping = aes(x = log2(kn_rep1 + 1),\n                           y = log2(kn_rep2 + 1)))\n\n\n\n\nBut now we want to compare the conditions to each other instead of comparing the biological replicates. To do that we need to summarize the data and compute the mean values. This is accomplished using dplyr::mutate.\nFirst read a little about ‘mutate()’ and ‘across()’. These are powerful tools for data transforms, but require some practice. They also require careful attention to the logic to ensure operations are occurring as you desire.\n\n?mutate()\n?across()\n\nNow lets calculate the within group means for our replicates. But before we do that, we should remember we also need out data to be log2(data+1) transformed.The challenge is we need to tell R that we want to transform each cell from the columns we point it to. We can accomplish this by using the vector function dplyr::across inside of mutate. There are many useful strategies for processing data by combining the mutate verb and across function.\n\ntb1 %>%\n  mutate(\n    across(\n      .cols = 3:6, # define the columns to mutate\n      .fns = ~ log2(. + 1) # define the function, the '.' represents the data in each cell\n    )\n  )\n\n# A tibble: 40,458 × 6\n   accession    gene                           kch_rep1 kch_rep2 kn_rep1 kn_rep2\n   <chr>        <chr>                             <dbl>    <dbl>   <dbl>   <dbl>\n 1 NM_001329047 Mia2|Ctage5|D12Bwg0579e|Mea6|…     5.48     5.22   4.94    4.80 \n 2 NM_172405    Abraxas1|3830405G04Rik|563040…     1.54     1.68   1.56    1.49 \n 3 NM_001359283 Sec63|5730478J10Rik|AI649014|…     4.34     4.23   3.83    3.79 \n 4 NM_001168290 Sugp2|Sfrs14|Srsf14|mKIAA0365…     3.64     3.30   3.58    3.10 \n 5 NM_001356498 Mtmr12|3Pap|4932703C11|C73001…     3.03     3.28   2.95    2.97 \n 6 NM_001358950 Cbx5|2610029O15Rik|C75991|HP1…     2.91     2.85   2.78    3.04 \n 7 NM_001166375 March1|2900024D24Rik|BB085186…     5.89     6.10   5.66    5.68 \n 8 NM_178061    Mob3b|8430436F23Rik|A430018A0…     1.33     1.38   0.790   0.931\n 9 NR_126506    Mdm4|4933417N07Rik|AA414968|A…     4.92     4.73   4.12    3.84 \n10 NR_029557    Mir145a|Mir145|Mirn145|mir-14…     0        0      0       0    \n# … with 40,448 more rows\n\n\nNow pipe the log normalization into a mean calculation, again using dplyr::mutate.\n\ntb1 %>%\n  mutate(\n    across(\n      .cols = 3:6, # define the columns to mutate\n      .fns = ~ log2(. + 1) # define the function, the '.' represents the data in each cell\n    )\n  ) %>%\n  mutate(\n    kch_mean = (kch_rep1 + kch_rep2)/2,\n    kn_mean = (kn_rep1 + kn_rep2)/2\n  )\n\n# A tibble: 40,458 × 8\n   accession    gene          kch_rep1 kch_rep2 kn_rep1 kn_rep2 kch_mean kn_mean\n   <chr>        <chr>            <dbl>    <dbl>   <dbl>   <dbl>    <dbl>   <dbl>\n 1 NM_001329047 Mia2|Ctage5|…     5.48     5.22   4.94    4.80      5.35   4.87 \n 2 NM_172405    Abraxas1|383…     1.54     1.68   1.56    1.49      1.61   1.53 \n 3 NM_001359283 Sec63|573047…     4.34     4.23   3.83    3.79      4.29   3.81 \n 4 NM_001168290 Sugp2|Sfrs14…     3.64     3.30   3.58    3.10      3.47   3.34 \n 5 NM_001356498 Mtmr12|3Pap|…     3.03     3.28   2.95    2.97      3.16   2.96 \n 6 NM_001358950 Cbx5|2610029…     2.91     2.85   2.78    3.04      2.88   2.91 \n 7 NM_001166375 March1|29000…     5.89     6.10   5.66    5.68      6.00   5.67 \n 8 NM_178061    Mob3b|843043…     1.33     1.38   0.790   0.931     1.36   0.860\n 9 NR_126506    Mdm4|4933417…     4.92     4.73   4.12    3.84      4.82   3.98 \n10 NR_029557    Mir145a|Mir1…     0        0      0       0         0      0    \n# … with 40,448 more rows\n\n\nNow let’s check our code is working by independently computing a test case. We can identify some test data by ‘slicing’ out a row using the dplyr::slice verb and selecting the columns to compute.\n\ntb1 %>% slice(1) %>% select(3:4)\n\n# A tibble: 1 × 2\n  kch_rep1 kch_rep2\n     <dbl>    <dbl>\n1     43.6     36.3\n\n\nManually calculate the average:\n\n(log2(43.6 + 1) + log2(36.3 + 1))/2\n\n[1] 5.350038\n\n\nDoes the value equal what we got above? What is different?\n\ntb1 %>%\n  mutate(\n    across(\n      .cols = 3:6, # define the columns to mutate\n      .fns = ~ log2(. + 1) # define the function, the '.' represents the data in each cell\n    )\n  ) %>%\n  mutate(\n    kch_mean = (kch_rep1 + kch_rep2)/2,\n    kn_mean = (kn_rep1 + kn_rep2)/2\n  ) %>% slice(1) %>% select(7)\n\n# A tibble: 1 × 1\n  kch_mean\n     <dbl>\n1     5.35\n\n\nNow lets add these components together and make the comparison scatter plot. Remember that now we are plotting the newly created variable that we generate within the piped commands. Thus we need to provide those variable names to geom_point(). And since we already log transformed, we should not do it again inside the ggplot code block. Note: here I am stashing the transformed data as a new variable. I then use this new variable to pipe into ggplot on a new coding line. We will use this variable further below.\n\ntb2 <- \n  tb1 %>%\n  mutate(\n    across(\n      .cols = 3:6, # define the columns to mutate\n      .fns = ~ log2(. + 1) # define the function, the '.' represents the data in each cell\n    )\n  ) %>%\n  mutate(\n    kch_mean = (kch_rep1 + kch_rep2)/2,\n    kn_mean = (kn_rep1 + kn_rep2)/2\n  )\n\ntb2 %>%\n  ggplot() +\n  geom_point(aes(x = kch_mean, y = kn_mean))\n\n\n\n\nOk great, but now we really want to know the identity of the genes with the largest differences! Let’s make a new variable with only those genes. We normally accomplish this using differential expression analysis. Today let’s use a simpler strategy by just comparing the fold-change.\nRemember, in logarithmic mathematics, log2(x+1) - log2(y+1) is equal to log2((x+1) / (y+1)). Since our data is already log transformed, the fold change is computer by comparing the difference of the numbers.\n\ntb2 %>% \n  mutate(\n    logFC = kch_mean - kn_mean\n  )\n\n# A tibble: 40,458 × 9\n   accession    gene  kch_rep1 kch_rep2 kn_rep1 kn_rep2 kch_mean kn_mean   logFC\n   <chr>        <chr>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>   <dbl>   <dbl>\n 1 NM_001329047 Mia2…     5.48     5.22   4.94    4.80      5.35   4.87   0.483 \n 2 NM_172405    Abra…     1.54     1.68   1.56    1.49      1.61   1.53   0.0830\n 3 NM_001359283 Sec6…     4.34     4.23   3.83    3.79      4.29   3.81   0.474 \n 4 NM_001168290 Sugp…     3.64     3.30   3.58    3.10      3.47   3.34   0.136 \n 5 NM_001356498 Mtmr…     3.03     3.28   2.95    2.97      3.16   2.96   0.196 \n 6 NM_001358950 Cbx5…     2.91     2.85   2.78    3.04      2.88   2.91  -0.0253\n 7 NM_001166375 Marc…     5.89     6.10   5.66    5.68      6.00   5.67   0.330 \n 8 NM_178061    Mob3…     1.33     1.38   0.790   0.931     1.36   0.860  0.496 \n 9 NR_126506    Mdm4…     4.92     4.73   4.12    3.84      4.82   3.98   0.845 \n10 NR_029557    Mir1…     0        0      0       0         0      0      0     \n# … with 40,448 more rows\n\n\nOk, now lets identify the instance were the logFC is > 1 or < -1. In other words, a fold change greater than ‘2’. For this we will use a new dplyr verb, dplyr::filter, which operates on data rows. We also will need to use an R logical operator. With R, ‘|’ is equivalent to or, ‘&’ is equivalent to and. Read more here: https://www.statmethods.net/management/operators.html\n\ntb2 %>% \n  mutate(\n    logFC = kch_mean - kn_mean\n  ) %>%\n  filter(logFC > 1 | logFC < -1)\n\n# A tibble: 1,757 × 9\n   accession    gene    kch_rep1 kch_rep2 kn_rep1 kn_rep2 kch_mean kn_mean logFC\n   <chr>        <chr>      <dbl>    <dbl>   <dbl>   <dbl>    <dbl>   <dbl> <dbl>\n 1 NM_021334    Itgax|…    2.06     2.05     6.58    7.04    2.06     6.81 -4.75\n 2 NM_001111059 Cd34|A…    0.579    0.573    2.06    1.86    0.576    1.96 -1.39\n 3 NM_022995    Pmepa1…    0.864    1.06     1.89    2.61    0.961    2.25 -1.29\n 4 NM_008433    Kcnn4|…    0.840    1.08     3.38    3.75    0.959    3.56 -2.60\n 5 NM_001130458 Tcn2|A…    9.61     9.87     8.33    7.84    9.74     8.09  1.65\n 6 NR_046233    Rn45s|…   10.9     11.1      8.59   10.5    11.0      9.56  1.46\n 7 NM_010730    Anxa1|…    0.766    1.05     3.25    3.90    0.906    3.57 -2.67\n 8 NR_122039    Tsc22d…    6.68     6.90     6.09    5.27    6.79     5.68  1.11\n 9 NM_001361978 Arsg|6…    2.12     2.56     1.50    1.07    2.34     1.29  1.05\n10 NM_145134    Spsb4|…    0.327    0.842    3.03    3.39    0.584    3.21 -2.63\n# … with 1,747 more rows\n\n\nThis yields a lot of ‘different’ genes! Lets make our space smaller by being more restrictive. Lets also generate a new variable with this smaller data set.\n\ntb3 <-\n  tb2 %>% \n  mutate(\n    logFC = kch_mean - kn_mean\n  ) %>%\n  filter(logFC > 6 | logFC < -6)\ntb3\n\n# A tibble: 8 × 9\n  accession    gene     kch_rep1 kch_rep2 kn_rep1 kn_rep2 kch_mean kn_mean logFC\n  <chr>        <chr>       <dbl>    <dbl>   <dbl>   <dbl>    <dbl>   <dbl> <dbl>\n1 NM_053110    Gpnmb|D…    1.03     0.969    8.08    8.79    1.00     8.44 -7.44\n2 NM_018866    Cxcl13|…   10.3      7.21     3.80    1.46    8.75     2.63  6.12\n3 NM_008605    Mmp12|A…    1.88     2.18     8.02    8.10    2.03     8.06 -6.03\n4 NM_053094    Cd163|C…   10.6     10.7      4.85    3.10   10.6      3.97  6.67\n5 NM_001320076 Mmp12|A…    1.87     2.17     8.02    8.09    2.02     8.05 -6.04\n6 NM_001204203 Spp1|2A…    0.597    0.570    5.79    7.39    0.584    6.59 -6.00\n7 NM_009263    Spp1|2A…    0.598    0.571    5.78    7.39    0.585    6.59 -6.00\n8 NM_001170395 Cd163|C…   10.5     10.7      4.83    3.08   10.6      3.95  6.66\n\n\nOk, 8 genes is a small enough set for now. Now lets add labels to our scatter plot above with the identifier information for these genes. We can accomplish this in several ways. One way is to overlay the text from the new filtered variable using geom_text(). In this case we must define the source of the data and the x and y positions must be the same. We also must supply the identity of the column containing the labels.\n\ntb2 %>% \n  ggplot() +\n  geom_point(aes(x = kch_mean, y = kn_mean)) +\n  geom_text(data = tb3, aes(x = kch_mean, y = kn_mean, label = accession))\n\n\n\n\nOk, that’s not bad, but a gene name would be better. Unfortunately, our gene names are buried in with a lot of information. Let’s extract it! That is made easy with columns using the tidyr::separate verb. Read about it first:\n\n?tidyr::separate()\n\n\ntb3 <- \n  tb2 %>% \n  mutate(\n    logFC = kch_mean - kn_mean\n  ) %>%\n  filter(logFC > 6 | logFC < -6) %>%\n  separate(col = 2, into = \"gene\", \n           sep = \"\\\\|\", # this part is tricky and follow 'regular expression' rules\n           remove = TRUE, extra = \"drop\")\n\nNow lets regenerate the scatter plot with the gene names labeled instead.\n\ntb2 %>% \n  ggplot() +\n  geom_point(aes(x = kch_mean, y = kn_mean)) +\n  geom_text(data = tb3, aes(x = kch_mean, y = kn_mean, label = gene))\n\n\n\n\nPretty good, but those duplicate gene names from splice variant accessions are cause the plot to look blurry. We can remove those without much forethought using the dplyr::distinct verb. That’s not the best idea long term, but useful for now. I will apply this to the initial data being plotted and also inside geom_text().\n\n?distinct()\n\ntb2 %>%\n  distinct(gene, .keep_all = TRUE) %>%\n  ggplot() +\n  geom_point(aes(x = kch_mean, y = kn_mean)) +\n  geom_text(data = tb3 %>% distinct(gene, .keep_all = TRUE),\n            aes(x = kch_mean, y = kn_mean, label = gene))\n\n\n\n\nNow we can stack it all together. Into one tibble. And use that tibble for our plot. Which also provides the opportunity to illustrate that dplyr functions can be layered inside of gglot functions.\n\ntb4 <-\n  readxl::read_xlsx(path = \"../Data/Source/1-s2.0-S107476132030159X-mmc3.xlsx\") %>%\n  dplyr::select(1:6) %>%\n  dplyr::rename(\n    accession = 1,\n    gene = 2,\n    kch_rep1 = 3,\n    kch_rep2 = 4,\n    kn_rep1 = 5,\n    kn_rep2 = 6\n  ) %>%\n  separate(col = 2, into = \"gene\", \n           sep = \"\\\\|\", # this part is tricky and follow 'regular expression' rules\n           remove = TRUE, extra = \"drop\") %>%\n  distinct(gene, .keep_all = TRUE) %>%\n  mutate(\n    across(\n      .cols = 3:6, # define the columns to mutate\n      .fns = ~ log2(. + 1) # define the function, the '.' represents the data in each cell\n    )\n  ) %>%\n  mutate(\n    kch_mean = (kch_rep1 + kch_rep2)/2,\n    kn_mean = (kn_rep1 + kn_rep2)/2\n  ) %>% \n  mutate(\n    logFC = kch_mean - kn_mean\n  )\ntb4\n\n# A tibble: 24,941 × 9\n   accession    gene  kch_rep1 kch_rep2 kn_rep1 kn_rep2 kch_mean kn_mean   logFC\n   <chr>        <chr>    <dbl>    <dbl>   <dbl>   <dbl>    <dbl>   <dbl>   <dbl>\n 1 NM_001329047 Mia2      5.48     5.22   4.94    4.80      5.35   4.87   0.483 \n 2 NM_172405    Abra…     1.54     1.68   1.56    1.49      1.61   1.53   0.0830\n 3 NM_001359283 Sec63     4.34     4.23   3.83    3.79      4.29   3.81   0.474 \n 4 NM_001168290 Sugp2     3.64     3.30   3.58    3.10      3.47   3.34   0.136 \n 5 NM_001356498 Mtmr…     3.03     3.28   2.95    2.97      3.16   2.96   0.196 \n 6 NM_001358950 Cbx5      2.91     2.85   2.78    3.04      2.88   2.91  -0.0253\n 7 NM_001166375 Marc…     5.89     6.10   5.66    5.68      6.00   5.67   0.330 \n 8 NM_178061    Mob3b     1.33     1.38   0.790   0.931     1.36   0.860  0.496 \n 9 NR_126506    Mdm4      4.92     4.73   4.12    3.84      4.82   3.98   0.845 \n10 NR_029557    Mir1…     0        0      0       0         0      0      0     \n# … with 24,931 more rows\n\n\n\ntb4 %>%\n  ggplot() +\n  geom_point(aes(x = kch_mean, y = kn_mean)) +\n  geom_text(data = tb4 %>%\n              filter(logFC > 6 | logFC < -6), \n            aes(x = kch_mean, y = kn_mean, label = gene))\n\n\n\n\nFinally, we have a plot that we may want to share. This is easy with ggplot using ggave(). We can either make the plot itself into a variable, or simply generate an image using the last ggplot created.\n\nplot1 <-\n  tb4 %>%\n  ggplot() +\n  geom_point(aes(x = kch_mean, y = kn_mean)) +\n  geom_text(data = tb4 %>%\n              filter(logFC > 6 | logFC < -6),\n            aes(x = kch_mean, y = kn_mean, label = gene))\nggsave(\n  filename = \"../Data/Plots/scatterchart1.png\",\n  plot = plot1,\n  width = 4,\n  height = 4,\n  units = \"in\",\n  dpi = 150,\n  bg = \"white\"\n)\n\nThe plot can be refined in many ways. And the text can be better controlled using the ggrepel package. See what you can do!\n\nrequire(ggrepel)\n\nLoading required package: ggrepel\n\ntb4 %>%\n  filter(kch_mean > 2 | kn_mean > 2) %>%\n  ggplot() +\n  geom_bin_2d(aes(x = kch_mean, y = kn_mean), bins = 101) +\n  scale_fill_continuous(type = \"viridis\") +\n  geom_text_repel(\n    data = tb4 %>%\n      filter(logFC > 6 | logFC < -6),\n    aes(x = kch_mean, y = kn_mean, label = gene),\n    fontface = \"italic\"\n  ) +\n  theme_classic(base_size = 10) +\n  theme(legend.position = \"none\", \n        axis.text = element_text(colour = \"black\")) +\n  labs(x = \"Healthy Kupffer cells\", \n       y = \"NASH Kupffer cells\", \n       title = \"RNA-seq, mean expression\") +\n  coord_fixed()\n\n\n\nggsave(\n  filename = \"../Data/Plots/scatterchart2.png\",\n  width = 4,\n  height = 4,\n  units = \"in\",\n  dpi = 150,\n  bg = \"white\"\n)"
  },
  {
    "objectID": "Docs/Sequencing/Introduction-RNASeqAnalysis.html#finished",
    "href": "Docs/Sequencing/Introduction-RNASeqAnalysis.html#finished",
    "title": "An introductory exploration of RNA-seq data using R and tidyverse",
    "section": "Finished!!",
    "text": "Finished!!\n\nsessioninfo::session_info(pkgs = NULL) %>% details::details(summary = 'Current session info', open = TRUE)\n\n\n\n Current session info \n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.0 (2021-05-18)\n os       macOS Big Sur 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-05-04\n pandoc   2.17.1.1 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n assertthat    0.2.1   2019-03-21 [2] CRAN (R 4.1.0)\n backports     1.4.1   2021-12-13 [2] CRAN (R 4.1.0)\n broom         0.7.12  2022-01-28 [2] CRAN (R 4.1.2)\n cellranger    1.1.0   2016-07-27 [2] CRAN (R 4.1.0)\n cli           3.1.1   2022-01-20 [1] CRAN (R 4.1.2)\n clipr         0.7.1   2020-10-08 [2] CRAN (R 4.1.0)\n colorspace    2.0-2   2021-06-24 [2] CRAN (R 4.1.0)\n crayon        1.4.2   2021-10-29 [2] CRAN (R 4.1.0)\n DBI           1.1.2   2021-12-20 [2] CRAN (R 4.1.0)\n dbplyr        2.1.1   2021-04-06 [2] CRAN (R 4.1.0)\n desc          1.4.0   2021-09-28 [1] CRAN (R 4.1.0)\n details       0.2.1   2020-01-12 [2] CRAN (R 4.1.0)\n digest        0.6.29  2021-12-01 [2] CRAN (R 4.1.0)\n dplyr       * 1.0.8   2022-02-08 [2] CRAN (R 4.1.0)\n ellipsis      0.3.2   2021-04-29 [2] CRAN (R 4.1.0)\n evaluate      0.14    2019-05-28 [2] CRAN (R 4.1.0)\n fansi         1.0.2   2022-01-14 [2] CRAN (R 4.1.2)\n farver        2.1.0   2021-02-28 [2] CRAN (R 4.1.0)\n fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.1.0)\n forcats     * 0.5.1   2021-01-27 [2] CRAN (R 4.1.0)\n fs            1.5.2   2021-12-08 [2] CRAN (R 4.1.0)\n generics      0.1.2   2022-01-31 [2] CRAN (R 4.1.2)\n ggplot2     * 3.3.5   2021-06-25 [2] CRAN (R 4.1.0)\n ggrepel     * 0.9.1   2021-01-15 [1] CRAN (R 4.1.0)\n glue          1.6.1   2022-01-22 [2] CRAN (R 4.1.2)\n gtable        0.3.0   2019-03-25 [2] CRAN (R 4.1.0)\n haven         2.4.3   2021-08-04 [1] CRAN (R 4.1.0)\n hms           1.1.1   2021-09-26 [2] CRAN (R 4.1.0)\n htmltools     0.5.2   2021-08-25 [2] CRAN (R 4.1.0)\n htmlwidgets   1.5.4   2021-09-08 [1] CRAN (R 4.1.0)\n httr          1.4.2   2020-07-20 [2] CRAN (R 4.1.0)\n jsonlite      1.7.3   2022-01-17 [2] CRAN (R 4.1.2)\n knitr         1.37    2021-12-16 [2] CRAN (R 4.1.0)\n labeling      0.4.2   2020-10-20 [2] CRAN (R 4.1.0)\n lifecycle     1.0.1   2021-09-24 [2] CRAN (R 4.1.0)\n lubridate     1.8.0   2021-10-07 [2] CRAN (R 4.1.0)\n magrittr      2.0.2   2022-01-26 [2] CRAN (R 4.1.2)\n modelr        0.1.8   2020-05-19 [2] CRAN (R 4.1.0)\n munsell       0.5.0   2018-06-12 [2] CRAN (R 4.1.0)\n pillar        1.7.0   2022-02-01 [2] CRAN (R 4.1.2)\n pkgconfig     2.0.3   2019-09-22 [2] CRAN (R 4.1.0)\n png           0.1-7   2013-12-03 [2] CRAN (R 4.1.0)\n purrr       * 0.3.4   2020-04-17 [2] CRAN (R 4.1.0)\n R6            2.5.1   2021-08-19 [2] CRAN (R 4.1.0)\n ragg          1.1.3   2021-06-09 [2] CRAN (R 4.1.0)\n Rcpp          1.0.8   2022-01-13 [2] CRAN (R 4.1.2)\n readr       * 2.1.2   2022-01-30 [1] CRAN (R 4.1.2)\n readxl        1.3.1   2019-03-13 [2] CRAN (R 4.1.0)\n reprex        2.0.1   2021-08-05 [2] CRAN (R 4.1.0)\n rlang         1.0.1   2022-02-03 [2] CRAN (R 4.1.2)\n rmarkdown     2.11    2021-09-14 [1] CRAN (R 4.1.0)\n rprojroot     2.0.2   2020-11-15 [1] CRAN (R 4.1.0)\n rstudioapi    0.13    2020-11-12 [2] CRAN (R 4.1.0)\n rvest         1.0.2   2021-10-16 [2] CRAN (R 4.1.0)\n scales        1.1.1   2020-05-11 [2] CRAN (R 4.1.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.1.0)\n stringi       1.7.6   2021-11-29 [2] CRAN (R 4.1.0)\n stringr     * 1.4.0   2019-02-10 [2] CRAN (R 4.1.0)\n systemfonts   1.0.2   2021-05-11 [2] CRAN (R 4.1.0)\n textshaping   0.3.6   2021-10-13 [2] CRAN (R 4.1.0)\n tibble      * 3.1.6   2021-11-07 [2] CRAN (R 4.1.0)\n tidyr       * 1.2.0   2022-02-01 [2] CRAN (R 4.1.2)\n tidyselect    1.1.1   2021-04-30 [2] CRAN (R 4.1.0)\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n tzdb          0.2.0   2021-10-27 [2] CRAN (R 4.1.0)\n utf8          1.2.2   2021-07-24 [2] CRAN (R 4.1.0)\n vctrs         0.3.8   2021-04-29 [2] CRAN (R 4.1.0)\n viridisLite   0.4.0   2021-04-13 [2] CRAN (R 4.1.0)\n withr         2.4.3   2021-11-30 [1] CRAN (R 4.1.0)\n xfun          0.29    2021-12-14 [1] CRAN (R 4.1.0)\n xml2          1.3.3   2021-11-30 [2] CRAN (R 4.1.0)\n yaml          2.2.2   2022-01-25 [2] CRAN (R 4.1.2)\n\n [1] /Users/tro3nr/Library/R/x86_64/4.1/library\n [2] /Library/Frameworks/R.framework/Versions/4.1/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "Docs/Sequencing/Nested-Bar-Charts.html",
    "href": "Docs/Sequencing/Nested-Bar-Charts.html",
    "title": "Saving bar charts from a nested list",
    "section": "",
    "text": "Sometimes it is useful to generate individual bar chart files (or other plots) instead of a facet plot. For this case I use a function to intersect a character list of genes of interest (GOI) with HOMER RNA-seq TPM data. Data is grouped via specified variable(s) and summary statistics are calculated. Data is then grouped by GOI and nested into a list. Finally, bar plots are iterated with purrr::map2() per GOI using calculated summary statistics.\nThis function can be downloaded here.\nWe will use data from from table S2 in Seidman et. al. Immunity. Volume 52, Issue 6, 16 June 2020, Pages 1057-1074.e7 again to demonstrate usage of the function. It can be downloaded here.\nThe nestedBarCharts function intersects the gene name from the “Annotation/Divergence” column with a user generated list of genes of interest. The function also requires replicate data with two grouping variables. Each data column should be named with in order with a primary grouping variable, a secondary grouping variable, and a replicate ID. Each of these variables should be separated by an _. As an example:\nprimaryGroup_secondaryGroup_replicate1\nWith this in mind, tidy up the data and rename the columns. Then generate a list of genes of interest.\nFunction usage: summary data and ggplot data are added to a user delcared variable, which I call output here. It can then be printed to an individual file per GOI as described below:\nThe resulting list of ggplots can then be written to images of your specification. First, generate a list of file names corresponding to each row.\nThen write the plots to the disk using the file name list in ‘plotnames’ created above, and the ggplot object list in output$plot. We can do this in an iterative fashion using purrr::map2 or purrr::walk2.\nCredit: https://aosmith.rbind.io/2018/08/20/automating-exploratory-plots/ Credit: https://www.painblogr.org/2020-06-19-purring-through-exploratory-analyses.html"
  },
  {
    "objectID": "Docs/Sequencing/Nested-Bar-Charts.html#finished",
    "href": "Docs/Sequencing/Nested-Bar-Charts.html#finished",
    "title": "Saving bar charts from a nested list",
    "section": "Finished!",
    "text": "Finished!\n\nsessioninfo::session_info(pkgs = NULL) %>% details::details(summary = 'Current session info', open = TRUE)\n\n\n\n Current session info \n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.0 (2021-05-18)\n os       macOS Big Sur 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2022-05-04\n pandoc   2.17.1.1 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n assertthat    0.2.1   2019-03-21 [2] CRAN (R 4.1.0)\n backports     1.4.1   2021-12-13 [2] CRAN (R 4.1.0)\n bit           4.0.4   2020-08-04 [1] CRAN (R 4.1.0)\n bit64         4.0.5   2020-08-30 [1] CRAN (R 4.1.0)\n broom         0.7.12  2022-01-28 [2] CRAN (R 4.1.2)\n cellranger    1.1.0   2016-07-27 [2] CRAN (R 4.1.0)\n cli           3.1.1   2022-01-20 [1] CRAN (R 4.1.2)\n clipr         0.7.1   2020-10-08 [2] CRAN (R 4.1.0)\n colorspace    2.0-2   2021-06-24 [2] CRAN (R 4.1.0)\n crayon        1.4.2   2021-10-29 [2] CRAN (R 4.1.0)\n DBI           1.1.2   2021-12-20 [2] CRAN (R 4.1.0)\n dbplyr        2.1.1   2021-04-06 [2] CRAN (R 4.1.0)\n desc          1.4.0   2021-09-28 [1] CRAN (R 4.1.0)\n details       0.2.1   2020-01-12 [2] CRAN (R 4.1.0)\n digest        0.6.29  2021-12-01 [2] CRAN (R 4.1.0)\n dplyr       * 1.0.8   2022-02-08 [2] CRAN (R 4.1.0)\n ellipsis      0.3.2   2021-04-29 [2] CRAN (R 4.1.0)\n evaluate      0.14    2019-05-28 [2] CRAN (R 4.1.0)\n fansi         1.0.2   2022-01-14 [2] CRAN (R 4.1.2)\n farver        2.1.0   2021-02-28 [2] CRAN (R 4.1.0)\n fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.1.0)\n forcats     * 0.5.1   2021-01-27 [2] CRAN (R 4.1.0)\n fs            1.5.2   2021-12-08 [2] CRAN (R 4.1.0)\n generics      0.1.2   2022-01-31 [2] CRAN (R 4.1.2)\n ggplot2     * 3.3.5   2021-06-25 [2] CRAN (R 4.1.0)\n glue          1.6.1   2022-01-22 [2] CRAN (R 4.1.2)\n gtable        0.3.0   2019-03-25 [2] CRAN (R 4.1.0)\n haven         2.4.3   2021-08-04 [1] CRAN (R 4.1.0)\n hms           1.1.1   2021-09-26 [2] CRAN (R 4.1.0)\n htmltools     0.5.2   2021-08-25 [2] CRAN (R 4.1.0)\n htmlwidgets   1.5.4   2021-09-08 [1] CRAN (R 4.1.0)\n httr          1.4.2   2020-07-20 [2] CRAN (R 4.1.0)\n jsonlite      1.7.3   2022-01-17 [2] CRAN (R 4.1.2)\n knitr         1.37    2021-12-16 [2] CRAN (R 4.1.0)\n labeling      0.4.2   2020-10-20 [2] CRAN (R 4.1.0)\n lifecycle     1.0.1   2021-09-24 [2] CRAN (R 4.1.0)\n lubridate     1.8.0   2021-10-07 [2] CRAN (R 4.1.0)\n magrittr      2.0.2   2022-01-26 [2] CRAN (R 4.1.2)\n modelr        0.1.8   2020-05-19 [2] CRAN (R 4.1.0)\n munsell       0.5.0   2018-06-12 [2] CRAN (R 4.1.0)\n pillar        1.7.0   2022-02-01 [2] CRAN (R 4.1.2)\n pkgconfig     2.0.3   2019-09-22 [2] CRAN (R 4.1.0)\n png           0.1-7   2013-12-03 [2] CRAN (R 4.1.0)\n purrr       * 0.3.4   2020-04-17 [2] CRAN (R 4.1.0)\n R6            2.5.1   2021-08-19 [2] CRAN (R 4.1.0)\n ragg          1.1.3   2021-06-09 [2] CRAN (R 4.1.0)\n Rcpp          1.0.8   2022-01-13 [2] CRAN (R 4.1.2)\n readr       * 2.1.2   2022-01-30 [1] CRAN (R 4.1.2)\n readxl        1.3.1   2019-03-13 [2] CRAN (R 4.1.0)\n reprex        2.0.1   2021-08-05 [2] CRAN (R 4.1.0)\n rlang         1.0.1   2022-02-03 [2] CRAN (R 4.1.2)\n rmarkdown     2.11    2021-09-14 [1] CRAN (R 4.1.0)\n rprojroot     2.0.2   2020-11-15 [1] CRAN (R 4.1.0)\n rstudioapi    0.13    2020-11-12 [2] CRAN (R 4.1.0)\n rvest         1.0.2   2021-10-16 [2] CRAN (R 4.1.0)\n scales        1.1.1   2020-05-11 [2] CRAN (R 4.1.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.1.0)\n stringi       1.7.6   2021-11-29 [2] CRAN (R 4.1.0)\n stringr     * 1.4.0   2019-02-10 [2] CRAN (R 4.1.0)\n systemfonts   1.0.2   2021-05-11 [2] CRAN (R 4.1.0)\n textshaping   0.3.6   2021-10-13 [2] CRAN (R 4.1.0)\n tibble      * 3.1.6   2021-11-07 [2] CRAN (R 4.1.0)\n tidyr       * 1.2.0   2022-02-01 [2] CRAN (R 4.1.2)\n tidyselect    1.1.1   2021-04-30 [2] CRAN (R 4.1.0)\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n tzdb          0.2.0   2021-10-27 [2] CRAN (R 4.1.0)\n utf8          1.2.2   2021-07-24 [2] CRAN (R 4.1.0)\n vctrs         0.3.8   2021-04-29 [2] CRAN (R 4.1.0)\n vroom         1.5.7   2021-11-30 [1] CRAN (R 4.1.0)\n withr         2.4.3   2021-11-30 [1] CRAN (R 4.1.0)\n xfun          0.29    2021-12-14 [1] CRAN (R 4.1.0)\n xml2          1.3.3   2021-11-30 [2] CRAN (R 4.1.0)\n yaml          2.2.2   2022-01-25 [2] CRAN (R 4.1.2)\n\n [1] /Users/tro3nr/Library/R/x86_64/4.1/library\n [2] /Library/Frameworks/R.framework/Versions/4.1/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "Docs/Sequencing/ngsScraper_KevinErnst.html",
    "href": "Docs/Sequencing/ngsScraper_KevinErnst.html",
    "title": "NGS scraper / downloader",
    "section": "",
    "text": "Author: Kevin Ernst, Weirauch lab\nContact: kevin.ernst -at- cchmc.org\nLicense: MIT\nThis script prompts for login credentials to the CCHMC DNA Sequencing and Genotyping Core’s “customer portal” and then generates a series of command-line invocations of curl, setting an appropriate cookie to authenticate you with the site, which you can then\nin order to download all NGS data that is available on the site under your login.\nThe included setup.py will install the script as ngsdl."
  },
  {
    "objectID": "Docs/Sequencing/ngsScraper_KevinErnst.html#requirements",
    "href": "Docs/Sequencing/ngsScraper_KevinErnst.html#requirements",
    "title": "NGS scraper / downloader",
    "section": "Requirements",
    "text": "Requirements\n\nPython ≥3.5\nRequests\nlxml"
  },
  {
    "objectID": "Docs/Sequencing/ngsScraper_KevinErnst.html#installation",
    "href": "Docs/Sequencing/ngsScraper_KevinErnst.html#installation",
    "title": "NGS scraper / downloader",
    "section": "Installation",
    "text": "Installation\n\nQuick Start\nThis procedure requires you have pip installed. If you are using Linux, your distro may already provide a package.\n# if you are on the HPC cluster, you will need to load a python/3.x module\nmodule load python3\n\n# install the latest release from GitLab using pip\npip install --user https://tfinternal.research.cchmc.org/gitlab/databank/seq-core-ngs-downloader/-/archive/master/seq-core-ngs-downloader-master.zip\n\n# make sure it works; otherwise, see the 'Updating Your PATH' section below\nngsdl --help\n\n# …or try this as a backup\npython -m cchmc_seq_core --help\nOlder versions of pip may require you to download the and manually extract the .zip file from GitLab first, like this:\ncurl -LOJ https://tf.cchmc.org/s/e1f9a\nunzip seq-core-ngs-downloader*.zip && rm -f seq-core-ngs-downloader*.zip\ncd seq-core-ngs-downloader*\npip install --user .\n\n# optionally delete the downloaded source code\ncd .. && rm -rf seq-core-ngs-downloader*\n\nUpdating Your PATH\nIf you install with pip install --user, that precludes the need for a virtual environment (see below), but necessitates that you manually add ~/.local/bin to your PATH if you want to be able to run this script from an arbitrary directory:\n# recommended place for PATH modifications is ~/.profile or ~/.bash_profile\ntest -f ~/.bash_profile && \\\n  echo 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bash_profile || \\\n  echo 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.profile\n\n# you will need to log out and back in to see the changes\nSome Linux distros do this by default now.\nOn a Mac, pip installs things to your (hidden) ~/Library folder. You will need to add $HOME/Library/Python/<python_maj.minor_version>/bin to your $PATH when using the system default Python, where <python_maj.minor_version> would be something like “2.7”, depending on which version of the OS you have.\n\n\n\nSetup for Local Development\nIf you are just experimenting, and don’t want to mess with setting your $PATH or potentially needing sudo to install, here’s a sure bet:\nGITLAB=https://tfwebdev.research.cchmc.org/gitlab\ngit clone $GITLAB/databank/seq-core-ngs-downloader\ncd seq-core-ngs-downloader\n\nvirtualenv venv      # or, possibly: python3 -m venv venv\n. venv/bin/activate  # activate the virtual environment\npip install -e .     # install using the 'setup.py' in the local directory\n\nngsdl --help         # make sure it works in the virtualenv\nThis repository includes a setuptools setup.py, which you can run in the usual way, if that’s your thing: python setup.py [--help | install]."
  },
  {
    "objectID": "Docs/Sequencing/ngsScraper_KevinErnst.html#basic-usage",
    "href": "Docs/Sequencing/ngsScraper_KevinErnst.html#basic-usage",
    "title": "NGS scraper / downloader",
    "section": "Basic Usage",
    "text": "Basic Usage\n# pretty failsafe; works because of cchmc_seq_core/__main__.py\npython -m cchmc_seq_core --help\n\n# redirect 'curl' commands into a script that you can run later\npython -m cchmc_seq_core > download.sh\nchmod a+x download.sh\n\n# or, if you've installed it properly and set up your $PATH\nngsdl > download.sh\nThe script will prompt you for your CCHMC credentials (which are not stored anywhere). These prompts and any other script output goes to stderr, so you can safely redirect the rest of the output to a file or pipe through grep, and so on.\n\nYou can suppress curl’s progress meters on all the download tasks with the -s / --silent option.\nYou can limit the types of files that would be downloaded (say, just download .bam files) with the -t / --data-type option, which may be specified more than once, like so:\nngsdl -t bam -t bai > download.sh\nSee the output of ngsdl --help for all the details."
  },
  {
    "objectID": "Docs/Sequencing/ngsScraper_KevinErnst.html#other-tips",
    "href": "Docs/Sequencing/ngsScraper_KevinErnst.html#other-tips",
    "title": "NGS scraper / downloader",
    "section": "Other Tips",
    "text": "Other Tips\nThere is no option (yet) to leave the “ignored” file types out of the output shell script entirely; that is, file types that you did not explicitly ask for with the -t / --data-type option.\nIf you use the -t option, the file types you didn’t explicitly ask for are just commented out, because the code was simpler that way. The default if you leave it off is to get all file types.\nIf this bothers you, the following small sed script will clean up some of the noise, while still preserving the experiment “headings”:\nngsdl -t fastq | sed '/^# /d; /^## --/d; /^$/d'\n\nGetting data files for a specific sequencing run\nTry something like this:\nngsdl | grep run0529 > download.sh\n\n# or, pipe it to a shell to start the downloads directly\nngsdl | grep run0529 | bash"
  },
  {
    "objectID": "Docs/Sequencing/ngsScraper_KevinErnst.html#references",
    "href": "Docs/Sequencing/ngsScraper_KevinErnst.html#references",
    "title": "NGS scraper / downloader",
    "section": "References",
    "text": "References\n\nCCHMC DNA Sequencing and Genotyping Core - on CenterLink"
  },
  {
    "objectID": "Docs/Sequencing/Integrating-RNASeq-ExpressionTPM-with-DeSeq2.html",
    "href": "Docs/Sequencing/Integrating-RNASeq-ExpressionTPM-with-DeSeq2.html",
    "title": "Integrating RNA expression data with differential statistics from DeSeq2",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n✓ tibble  3.1.6     ✓ dplyr   1.0.8\n✓ tidyr   1.2.0     ✓ stringr 1.4.0\n✓ readr   2.1.2     ✓ forcats 0.5.1\n\n\nWarning: package 'tidyr' was built under R version 4.1.2\n\n\nWarning: package 'readr' was built under R version 4.1.2\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\n\nRead in normalized TPM expression data\n\nread_tsv(\"../Data/Source/rawT.txt\") %>% colnames()\n\nNew names:\n* `` -> ...1\n\n\nRows: 23608 Columns: 27\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr  (1): ...1\ndbl (26): BALBcJ_F0_Control_BALB01C, BALBcJ_F0_Control_BALB01D, C57BL6J_F0_C...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n [1] \"...1\"                       \"BALBcJ_F0_Control_BALB01C\" \n [3] \"BALBcJ_F0_Control_BALB01D\"  \"C57BL6J_F0_Control_C5701C\" \n [5] \"C57BL6J_F0_Control_C5701D\"  \"BALBcJ_F0_LPS_20210513_1a\" \n [7] \"BALBcJ_F0_LPS_20210513_1b\"  \"C57BL6J_F0_LPS_20210513_2b\"\n [9] \"C57BL6J_F0_LPS_20210513_2c\" \"BALBcJ_F1_Control_cb61a\"   \n[11] \"BALBcJ_F1_Control_cb61b\"    \"BALBcJ_F1_Control_cb61c\"   \n[13] \"BALBcJ_F1_Control_cb61d\"    \"C57BL6J_F1_Control_cb61a\"  \n[15] \"C57BL6J_F1_Control_cb61b\"   \"C57BL6J_F1_Control_cb61c\"  \n[17] \"C57BL6J_F1_Control_cb61d\"   \"BALBcJ_F1_LPS_cb61a\"       \n[19] \"BALBcJ_F1_LPS_cb61b\"        \"BALBcJ_F1_LPS_cb62a\"       \n[21] \"BALBcJ_F1_LPS_cb62b\"        \"BALBcJ_F1_LPS_cb62c\"       \n[23] \"C57BL6J_F1_LPS_cb61a\"       \"C57BL6J_F1_LPS_cb61b\"      \n[25] \"C57BL6J_F1_LPS_cb62a\"       \"C57BL6J_F1_LPS_cb62b\"      \n[27] \"C57BL6J_F1_LPS_cb62c\"      \n\ntpm <- read_tsv(\"../Data/Source/rawT.txt\") %>% select(1:5) %>% rename(geneID = 1)\n\nNew names:\n* `` -> ...1\nRows: 23608 Columns: 27── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr  (1): ...1\ndbl (26): BALBcJ_F0_Control_BALB01C, BALBcJ_F0_Control_BALB01D, C57BL6J_F0_C...\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nRead in DeSeq2 differential expression data for these selected comparisons\n\ndiff <- read_tsv(\"../Data/Source/BALBcJ_F0_Control.vs.C57BL6J_F0_Control.scatter.txt\") %>% rename(geneID = 1)\n\nNew names:\n* `` -> ...1\n\n\nRows: 7664 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): ...1, contrast\ndbl (6): baseMean, log2FoldChange, lfcSE, stat, pvalue, padj\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nNow merge data together. This will invovle using the join functions that are part of dplyr. Dplyr has mutate joins (inner_join, full_join, right_join, left_join) and filter joins (semi_join and anti_join), including full_join, semi_join, left_join, right_join, inner_join, and I probably forgot a few.\nFor this case we want consider genes that meet minimal expression criteria and were included in the differential expression analysis. So we will use inner_join\n\nmerge <-  inner_join(x = tpm, y = diff, by = \"geneID\")\nmergeMean <- merge %>%\n  mutate(meanBALB = (BALBcJ_F0_Control_BALB01C + BALBcJ_F0_Control_BALB01D) /\n           2) %>%\n  mutate(meanC57 = (C57BL6J_F0_Control_C5701C + C57BL6J_F0_Control_C5701D) /\n           2)"
  },
  {
    "objectID": "Docs/Sequencing/Exporting-Gene-Lists.html",
    "href": "Docs/Sequencing/Exporting-Gene-Lists.html",
    "title": "Exporting gene lists with R",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n✓ tibble  3.1.6     ✓ dplyr   1.0.8\n✓ tidyr   1.2.0     ✓ stringr 1.4.0\n✓ readr   2.1.2     ✓ forcats 0.5.1\n\n\nWarning: package 'tidyr' was built under R version 4.1.2\n\n\nWarning: package 'readr' was built under R version 4.1.2\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\n\n\ntb1 <-\n  readxl::read_excel(path = \"../Data/Source/1-s2.0-S107476132030159X-mmc3.xlsx\") %>%\n  dplyr::select(1:6) %>%\n  dplyr::rename(\n    accession = 1,\n    gene = 2,\n    kch_rep1 = 3,\n    kch_rep2 = 4,\n    kn_rep1 = 5,\n    kn_rep2 = 6\n  ) %>%\n  mutate(across(.cols = 3:6,\n                .fns = ~ log2(. + 1))) %>%\n  mutate(kch_mean = (kch_rep1 + kch_rep2) / 2,\n         kn_mean = (kn_rep1 + kn_rep2) / 2) %>%\n  mutate(logFC = kch_mean - kn_mean) %>%\n  separate(\n    col = 2,\n    into = \"gene\",\n    sep = \"\\\\|\",\n    remove = TRUE,\n    extra = \"drop\"\n  )\n\n\nnash <-\n  tb1 %>% \n  filter(logFC < -1) %>%\n  distinct(gene) %>%\n  write_csv(file = \"../Data/Processed/nash.csv\")\n\ncontrol <-\n  tb1 %>% \n  filter(logFC > 1) %>%\n  distinct(gene) %>%\n  write_csv(file = \"../Data/Processed/control.csv\")"
  },
  {
    "objectID": "Docs/Analysis/processingRNASeqData.html",
    "href": "Docs/Analysis/processingRNASeqData.html",
    "title": "Processing RNA-seq data",
    "section": "",
    "text": "(Slightly more) advanced users.\nIf RNA-seq data from the dUTP protocol is single read, then use the -flip option in HOMER makeTagDirectory.\nmakeTagDirectory <tagDirectoryName> <filename.sam> -genome <experiment_genome> \\\n-checkGC -format sam -flip\nIf RNA-seq data from the dUTP protocol is paired end then use the -sspe -flip options in HOMER makeTagDirectory.\nmakeTagDirectory <tagDirectoryName> <filename.sam> -genome <experiment_genome> \\\n-checkGC -sspe -format sam -flip\nData type, quality, etc. may require use of altered commands with STAR and/or HOMER. More information on these applications can be found by reading the documentation. For reference, below is an example bat script for mapping paired end RNA-seq data with STAR and generating an appropriately formatted HOMER tag directory.\n#BSUB -W 1:00\n#BSUB -n 16\n#BSUB -M 40000\n#BSUB -e ./bsub_scripts/mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002.err\n#BSUB -o ./bsub_scripts/mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002.out# load modulesmodule load STAR/2.7.9module load homer/4.11\n\n# execute STAR\nSTAR \\    \n--runThreadN 16 \\    \n--genomeDir /data/hpc-troutman/data/genomes/indexes/star/mm10_starIndex/ \\    --readFilesCommand zcat \\    \n--readFilesIn .//mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002_R1.fastq.gz .//mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002_R2.fastq.gz \\    \n--outFileNamePrefix ./star_out /mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002.mm10. \\    --outSAMtype SAM\n\n# remove STAR temporary directories\nrm -r ./star_out/mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002.mm10._STARtmp\n\n# execute HOMER makeTagDirectory\nmakeTagDirectory ./tag_directories/mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002.mm10/ ./star_out/mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002.mm10.Aligned*am -genome mm10 -checkGC -format sam -sspe -flip\n\n# copy STAR log files to the HOMER tag directory\ncp ./star_out/mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002.*Log* ./tag_directories/mouse_c57bl6j_Male_BMDM_RNA_KLA2hr_TDT_l20220224_ACGATCTA_GCAATATG_S14_L002.mm10/\n\necho Done!\nThis script can be named <example>.bat and submitted to the scheduler on the cluster using:\nbsub < example.bat\nMultiple bat scripts can be submitted using a bash for loop:\nfor i in <*wildcardmatchingscriptname.bat>; do bsub < $i; sleep 1; done"
  }
]